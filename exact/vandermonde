#!/usr/bin/env python
# Precomputed LU factorization of the univariate Vandermonde matrix for perturb.cpp

from __future__ import with_statement,division
from sympy import *

# Max degree 13 also fits in 32-bit ints, but 12 should be enough for now
max_degree = 12

def sigma_table():
  # Compute tau and sigma
  tau = {}
  tau[1,1] = 0
  for k in xrange(1,max_degree):
    tau[1,k+1] = tau[1,k]-k
  for r in xrange(1,max_degree):
    tau[r+1,r+1] = -r*tau[r,r]
    for k in xrange(r+1,max_degree):
      tau[r+1,k+1] = tau[r+1,k]-k*tau[r,k]
  def sigma(n,k):
    return tau[n-k,n]

  # Generate table
  table = [sigma(n,k) for n in xrange(max_degree+1) for k in xrange(n)]
  assert len(table)==max_degree*(max_degree+1)/2

  # Write table and inline helper
  print '// sigma(n,k) = tau_{n-k}(n)'
  print 'static inline int sigma(const int n, const int k) {'
  print '  static const int table[%d] = {%s};'%(len(table),','.join(map(str,table)))
  print '  assert(unsigned(n)<=unsigned(max_degree) && unsigned(k)<unsigned(n));'
  print '  return table[n*(n-1)/2+k];'
  print '}'

def univariate_table():
  # Compute the nonspecial lower triangular factor in a LU-decomposition of the Vandermonde matrix.
  # This is the transpose of U from
  #
  #   Oliver 2009, "On multivariate interpolation".
  #
  # It's transposed because we prefer to multiply matrices on the right.  The other factor is exactly sigma from above.
  L = Matrix([[(prod(i-k for k in xrange(j)) if i>=j else 0) for j in xrange(max_degree+1)] for i in xrange(max_degree+1)])
  Li = L.inv()
  # Conveniently, Li[i,j] * i! is always an integer, so we output that as a table.
  Lii = diag(*map(factorial,xrange(max_degree+1)))*Li
  for i in xrange(max_degree+1):
    assert Lii[i,i]==1
  print '// Strict lower triangle of the LU decomposition, with row k multiplied by k! to clear fractions.'
  print 'static inline int lower_triangle(const int n, const int k) {'
  table = [Lii[i,j] for i in xrange(max_degree+1) for j in xrange(i)]
  for x in table:
    assert denom(x)==1
  assert len(table)==max_degree*(max_degree+1)/2
  print '  static const int16_t table[%d] = {%s};'%(len(table),','.join(map(str,table)))
  print '  assert(unsigned(n)<=unsigned(max_degree) && unsigned(k)<unsigned(n));'
  print '  return table[n*(n-1)/2+k];'
  print '}'

def main():
  print '// Autogenerated LU factorization of the Vandermonde matrix for points 0,1,...,max_degree: DO NOT EDIT'
  print '// See exact/vandermonde and the comments in exact/perturb.cpp for details.'
  print '#pragma once\n\nnamespace other {\n'
  print 'const int max_degree = %d;\n'%max_degree
  sigma_table()
  print
  univariate_table() 
  print '\n}'

if __name__=='__main__':
  main()
