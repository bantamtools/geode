#pragma once
// A halfedge data structure representing oriented planar graphs.
// This class represents topology only, not geometry.

#include <geode/array/Field.h>
#include <geode/array/RawField.h>
#include <geode/array/view.h>
#include <geode/mesh/ids.h>

namespace geode {

// Important invariants:
//   1. For a valid HalfedgeId he, he = next(he) will eventually form a cycle
//   2. prev and next invert each other (i.e. prev(next(he)) == he)
//   3. src(next(he)) == dst(he) for all halfedges
// There can be self loops: src(he) == dst(he) and even next(he) == he
// Not enforced programmatically, but should be true for ArcGraphs: Given vertices v0,v1, there are at most four halfedges from v0 to v1.
// After borders are have been initialized we will also have:
//   4. For a valid BorderId b, b = next(b) will eventually form a cycle
//   5. prev and next for BorderId's will also invert each other
//   6. border(he) == border(next(he)) for all halfedges
//   7. face(b) == face(next(b)) for all borders
// Faces are initialized by calling new_face_for_border or add_to_face
// Faces are allowed to be invalid for some borders (such as if embedding is unknown), but some utilities require face(he).valid() == face(reverse(he)).valid()
// Unlike in HalfedgeMesh, an invalid face id doesn't indicate the boundary face
class HalfedgeGraph : public Object {
public:
  GEODE_DECLARE_TYPE(GEODE_CORE_EXPORT)
  typedef Object Base;

  struct OutgoingCirculator;
  struct BorderCirculator;
  struct FaceCirculator;

  struct HalfedgeInfo {
    HalfedgeId prev, next;
    VertexId src;
    BorderId border; // Will not be valid unless initialize_borders has been called
  };

  struct VertexInfo {
    HalfedgeId halfedge; // src(halfedge) == v if edge is valid
  };

  struct BorderInfo {
    BorderId prev, next;
    HalfedgeId halfedge;
    FaceId face;
  };

  struct FaceInfo {
    BorderId border;
  };

  Field<HalfedgeInfo,HalfedgeId> halfedges_;
  Field<VertexInfo,VertexId> vertices_; // src(vertices_[v].halfedge) == v if valid

  // Border info is generated by calling initialize_borders after which edges must no longer be modified
  Field<BorderInfo, BorderId> borders_;
  Field<FaceInfo, FaceId> faces_;

  void initialize_borders(); // Walks halfedges.next and constructs borders

  // Predicates to check state of border data (These are intended for asserts only, user should know if borders have been initialized)
  bool has_all_border_data() const { return !borders_.empty() || halfedges_.empty(); }
  bool safe_to_modify_edges() const { return borders_.empty(); }

  bool check_invariants() const; // Attempt to check that all info is consistent. Only intended for debugging
protected:
  RawField<Vector<HalfedgeInfo,2>, EdgeId> edge_view() {
    return RawField<Vector<HalfedgeInfo,2>, EdgeId>(vector_view<2>(halfedges_.flat));
  }

  HalfedgeId* prev_ptr(const HalfedgeId h)   { return &(halfedges_[h].prev); }
  HalfedgeId* next_ptr(const HalfedgeId h)   { return &(halfedges_[h].next); }
  HalfedgeId* halfedge_ptr(const VertexId v) { return &(vertices_[v].halfedge); }
  HalfedgeId* halfedge_ptr(const BorderId b) { return &(borders_[b].halfedge); }
  Vector<HalfedgeId*,4> halfedge_refs(const HalfedgeId h); // Some of these will be null if unused

  VertexId* src_ptr(const HalfedgeId h)      { return &(halfedges_[h].src); }

  GEODE_CORE_EXPORT HalfedgeGraph();
  GEODE_CORE_EXPORT HalfedgeGraph(const HalfedgeGraph& g);
public:
  ~HalfedgeGraph();
  // Copy the graph
  GEODE_CORE_EXPORT Ref<HalfedgeGraph> copy() const;

  // Count various features
  int n_vertices()  const { return vertices_.size(); }
  int n_halfedges() const { return halfedges_.size(); }
  int n_edges()     const { return halfedges_.size()>>1; }
  int n_borders()   const { assert(has_all_border_data()); return borders_.size(); }
  int n_faces()     const { return faces_.size(); }

  // Walk around the halfedge structure.  These always succeed given valid ids,
  // but may return invalid ids as a result
  HalfedgeId halfedge(const VertexId v) const { assert(!valid(vertices_[v].halfedge) || src(vertices_[v].halfedge) == v); return vertices_[v].halfedge; }
  HalfedgeId prev(const HalfedgeId e)   const { return halfedges_[e].prev; }
  HalfedgeId next(const HalfedgeId e)   const { return halfedges_[e].next; }
  EdgeId     edge(const VertexId v)     const { return edge(halfedge(v)); } // Warning, this will fail if no edge connected to vertex exists
  VertexId   src(const HalfedgeId e)    const { return halfedges_[e].src; }
  VertexId   dst(const HalfedgeId e)    const { return src(reverse(e)); }
  VertexId   src(const EdgeId e)        const { return src(halfedge(e,false)); }
  VertexId   dst(const EdgeId e)        const { return src(halfedge(e,true)); }
  HalfedgeId left(const HalfedgeId e)   const { return reverse(prev(e)); }
  HalfedgeId right(const HalfedgeId e)  const { return next(reverse(e)); }

  static HalfedgeId reverse(const HalfedgeId e)               { assert(e.valid()); return HalfedgeId(e.id^1); }
  static EdgeId     edge(const HalfedgeId e)                  { assert(e.valid()); return EdgeId(e.id>>1); }
  static HalfedgeId halfedge(const EdgeId e, const bool which){ assert(e.valid()); return HalfedgeId((e.id<<1)|(which<<0)); }
  static Vector<HalfedgeId,2> halfedges(const EdgeId e)       { assert(e.valid()); return vec(halfedge(e,0),halfedge(e,1)); }
  static bool is_forward(HalfedgeId e)                        { assert(e.valid()); return (e.id&1) == 0; }

  // These require border data to be initialized
  BorderId   border(const HalfedgeId e)     const { assert(has_all_border_data()); return halfedges_[e].border; }
  BorderId   opp_border(const HalfedgeId e) const { return border(reverse(e)); }
  HalfedgeId halfedge(const BorderId b)     const { return borders_[b].halfedge; }
  BorderId   next(const BorderId b)         const { return borders_[b].next; }
  BorderId   prev(const BorderId b)         const { return borders_[b].prev; }

  // These require face data to be initialized
  FaceId     face(const BorderId b)       const { assert(has_all_border_data()); return borders_[b].face; }
  FaceId     face(const HalfedgeId e)     const { return face(border(e)); }
  FaceId     opp_face(const HalfedgeId e) const { return face(reverse(e)); }
  BorderId   border(const FaceId f)       const { return faces_[f].border; }
  HalfedgeId halfedge(const FaceId f)     const { return halfedge(border(f)); }
  Vector<FaceId,2> faces(const EdgeId e)  const { return vec(face(halfedge(e,0)),face(halfedge(e,1))); }

  // Check id validity
  bool valid(const VertexId v)   const;
  bool valid(const HalfedgeId e) const;
  bool valid(const EdgeId e)     const;
  bool valid(const BorderId b)   const;
  bool valid(const FaceId f)     const;

  bool isolated(VertexId v)     const { return !valid(halfedge(v)); }

  // Iterate over vertices, edges, borders, or faces
  Range<IdIter<VertexId>>   vertices()  const { return id_range<VertexId>  (n_vertices()); }
  Range<IdIter<HalfedgeId>> halfedges() const { return id_range<HalfedgeId>(n_halfedges()); }
  Range<IdIter<EdgeId>>     edges()     const { return id_range<EdgeId>    (n_edges()); }
  Range<IdIter<BorderId>>   borders()   const { return id_range<BorderId>  (n_borders()); }
  Range<IdIter<FaceId>>     faces()     const { return id_range<FaceId>    (n_faces()); }

  Vector<VertexId,2> vertices(const HalfedgeId e) const {
    return vec(src(e),dst(e));
  }
  Vector<VertexId,2> vertices(const EdgeId e) const { return vertices(halfedge(e, false)); }

  inline Range<OutgoingCirculator> outgoing(const VertexId v) const;
  inline Range<BorderCirculator> border_edges(const HalfedgeId e) const; // This version is safe to call even without border data present
  inline Range<BorderCirculator> border_edges(const BorderId b) const { return border_edges(halfedge(b)); }
  inline Range<FaceCirculator> face_borders(const BorderId b) const; // This relies on border data, but is safe to call without face data present
  inline Range<FaceCirculator> face_borders(const FaceId f) const { return face_borders(border(f)); }

  // Compute the edge degree of a vertex in O(degree) time.
  GEODE_CORE_EXPORT int degree(const VertexId v) const;

  // All connected edges to vertex
  GEODE_CORE_EXPORT Array<VertexId> one_ring(const VertexId v) const;

  // Add a new isolated vertex and return its id
  GEODE_CORE_EXPORT VertexId add_vertex();

  // Add n isolated vertices
  GEODE_CORE_EXPORT void add_vertices(const int n);

  GEODE_CORE_EXPORT EdgeId split_edge(const EdgeId e, const VertexId use_vertex); // If vertex is not isolated, edges will be linked arbitrarily
  GEODE_CORE_EXPORT EdgeId split_edge_across(const EdgeId e0, const HalfedgeId split);

  // Permute ids without changing underlying structure
  GEODE_CORE_EXPORT void swap_ids(const VertexId v0, const VertexId v1);
  GEODE_CORE_EXPORT void swap_ids(const EdgeId e0, const EdgeId e1);

  // To keep contiguous ids we only allow removal at the end. Can combine with swap_ids to erase primitives not at the end
  GEODE_CORE_EXPORT void erase_last_vertex(); // Vertex must be isolated
  GEODE_CORE_EXPORT void erase_last_edge();

  // Use only through HalfedgeGraph::outgoing()
  struct OutgoingCirculator {
    const HalfedgeGraph& graph;
    HalfedgeId e;
    bool first;
    OutgoingCirculator(const HalfedgeGraph& graph, const HalfedgeId e, const bool first) : graph(graph), e(e), first(first) {}
    void operator++() { e = graph.left(e); first = false; }
    bool operator!=(const OutgoingCirculator& o) { return first || e!=o.e; } // For use only inside range-based for loopsHalfedgeId operator*() const { return e; }
    HalfedgeId operator*() const { return e; }
  };

  // Use only through HalfedgeGraph::border_edges()
  struct BorderCirculator { // Iterator to walk halfedges for a border
    const HalfedgeGraph& graph;
    HalfedgeId e;
    bool first;
    BorderCirculator(const HalfedgeGraph& graph, const HalfedgeId e, const bool first) : graph(graph), e(e), first(first) {}
    void operator++() { e = graph.next(e); first = false; }
    bool operator!=(const BorderCirculator& o) { assert(&graph == &o.graph); return first || e!=o.e; } // For use only inside range-based for loops
    HalfedgeId operator*() const { return e; }
  };

  // Use only through HalfedgeGraph::face_borders()
  struct FaceCirculator { // Iterator to walk borders for a face
    const HalfedgeGraph& graph;
    BorderId b;
    bool first;
    FaceCirculator(const HalfedgeGraph& graph, const BorderId b, const bool first) : graph(graph), b(b), first(first) {}
    void operator++() { b = graph.next(b); first = false; }
    bool operator!=(const FaceCirculator o) { assert(&graph == &o.graph); return first || b!=o.b; } // For use only inside range-based for loops
    BorderId operator*() const { return b; }
  };

  // The remaining functions are mainly for internal use, or for external routines that perform direct surgery
  // on the halfedge structure.  Use with caution!

  // Adds a new edge. New halfedges will be linked with arbitrarily choosen neighbor at src and dst
  EdgeId unsafe_add_edge(const VertexId src, const VertexId dst);

  void unsafe_disconnect_src(const HalfedgeId he); // Creates a dangling edge without a valid vertex. Many graph operations will be unsafe until unsafe_reconnect_src is called
  void unsafe_reconnect_src(const HalfedgeId he, const VertexId new_src); // Reconnects dangling edge created by unsafe_disconnect_src to given vertex. prev/next will be arbitrarily choosen

  void unsafe_flip_edge(const EdgeId e); // Swaps halfedges so that src(e) becomes dst(e) and vise versa. This can affect halfedge linkage
  // Link two edges together
  void unsafe_link(const HalfedgeId p, const HalfedgeId n) {
    halfedges_[p].next = n;
    halfedges_[n].prev = p;
    assert(dst(p) == src(n));
  }

  // Face operations. These may only be called after initialize_borders
  FaceId new_face_for_border(const BorderId b); // 'b' must not already belong to a face
  void add_to_face(const FaceId f, const BorderId child); // 'f' must be a valid face. 'child' must not already belong to a face
  void initialize_remaining_faces(); // Creates new faces for any borders that don't already have one
};

std::ostream& operator<<(std::ostream& os, const HalfedgeGraph& g);

inline Range<HalfedgeGraph::OutgoingCirculator> HalfedgeGraph::outgoing(const VertexId v) const {
  const auto e = halfedge(v);
  const HalfedgeGraph::OutgoingCirculator c(*this,e,e.valid());
  return Range<HalfedgeGraph::OutgoingCirculator>(c,c);
}

inline Range<HalfedgeGraph::BorderCirculator> HalfedgeGraph::border_edges(const HalfedgeId e) const {
  const BorderCirculator iter(*this,e,e.valid());
  return Range<BorderCirculator>(iter,iter);
}

inline Range<HalfedgeGraph::FaceCirculator> HalfedgeGraph::face_borders(const BorderId b) const {
  assert(has_all_border_data());
  const FaceCirculator iter(*this,b,b.valid());
  return Range<FaceCirculator>(iter,iter);
}

struct CrossingInfo {
  static int unset_depth() { return std::numeric_limits<int>::max(); }
  HalfedgeId next;
  int depth;
  CrossingInfo()
   : next(HalfedgeId())
   , depth(unset_depth())
  { }
};
// Compute shortest path (in edge crossings) from each face to boundary_face.  This is always nonnegative.
// Requires face(he).valid() == face(reverse(he)).valid()
Field<CrossingInfo, FaceId> get_crossing_depths(const HalfedgeGraph& g, const FaceId boundary_face);

// Compute winding numbers for all faces starting with a value of 0 inside boundary_face and using edge_weights
// If e is an EdgeId, the weight for 'g.halfedge(e,0)' will be 'edge_weights[e]' and the weight for 'g.halfedge(e,1)' will be '-edge_weights[e]'
// Requires face(he).valid() == face(reverse(he)).valid()
// This function requires manifold edge weights (i.g. all edge_weights come from closed contours) where any path will have the same winding
Field<int, FaceId> compute_winding_numbers(const HalfedgeGraph& g, const FaceId boundary_face, const RawField<const int, EdgeId> edge_weights);

// Compute interior and exterior boundaries of region for union of all faces that are true in interior_faces
// Requires face(he).valid() == face(reverse(he)).valid() and will ignore components with invalid faces
Nested<HalfedgeId> extract_region(const HalfedgeGraph& g, const RawField<const bool, FaceId> interior_faces);

} // namespace geode