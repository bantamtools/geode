// A halfedge data structure representing oriented planar graphs.
// This class represents topology only, not geometry.

#include <geode/array/Field.h>
#include <geode/mesh/ids.h>

namespace geode {

// Important invariants:
//   1. For a valid HalfedgeId he, he = next(he) will eventually form a cycle
//   2. prev and next invert each other (i.e. prev(next(he)) == he)
//   3. src(next(he)) == dst(he) for all halfedges
// There can be self loops: src(he) == dst(he) and even next(he) == he
// Not enforced programmatically, but should be true for ArcGraphs: Given vertices v0,v1, there are at most four halfedges from v0 to v1.
// After borders are have been initialized we will also have:
//   4. For a valid BorderId b, b = next(b) will eventually form a cycle
//   5. prev and next for BorderId's will also invert each other
//   6. border(he) == border(next(he)) for all halfedges
//   7. face(b) == face(next(b)) for all borders
// Faces are initialized by calling new_face_for_border or add_to_face
// Faces are allowed to be invalid for some borders (such as if embedding is unknown), but some utilities require face(he).valid() == face(reverse(he)).valid()
// Unlike in HalfedgeMesh, an invalid face id doesn't indicate the boundary face

class HalfedgeGraph : public Object {
public:
  GEODE_DECLARE_TYPE(GEODE_CORE_EXPORT)
  typedef Object Base;

  struct OutgoingCirculator;
  struct BorderCirculator;
  struct FaceCirculator;

  struct HalfedgeInfo {
    HalfedgeId prev, next;
    VertexId src;
    BorderId border; // Will not be valid unless initialize_borders has been called
  };

  struct BorderInfo {
    BorderId prev, next;
    HalfedgeId halfedge;
    FaceId face;
  };

  struct FaceInfo {
    BorderId border;
  };

  Field<HalfedgeInfo,HalfedgeId> halfedges_;
  Field<HalfedgeId,VertexId> vertex_to_edge_; // src(vertex_to_edge_[v]) == v if valid

  // Border info is generated by calling initialize_borders after which edges must no longer be modified
  Field<BorderInfo, BorderId> borders_;
  Field<FaceInfo, FaceId> faces_;

  void initialize_borders(); // Walks halfedges.next and constructs borders

  // Predicates to check state of border data (These are intended for asserts only, user should know if borders have been initialized)
  bool has_all_border_data() const { return !borders_.empty() || halfedges_.empty(); }
  bool safe_to_modify_edges() const { return borders_.empty(); }

protected:
  GEODE_CORE_EXPORT HalfedgeGraph();
  GEODE_CORE_EXPORT HalfedgeGraph(const HalfedgeGraph& g);
public:
  ~HalfedgeGraph();
  // Copy the graph
  GEODE_CORE_EXPORT Ref<HalfedgeGraph> copy() const;

  // Count various features
  int n_vertices()  const { return vertex_to_edge_.size(); }
  int n_halfedges() const { return halfedges_.size(); }
  int n_edges()     const { return halfedges_.size()>>1; }
  int n_borders()   const { assert(has_all_border_data()); return borders_.size(); }
  int n_faces()     const { return faces_.size(); }

  // Walk around the halfedge structure.  These always succeed given valid ids,
  // but may return invalid ids as a result
  HalfedgeId halfedge(VertexId v)           const { assert(!valid(vertex_to_edge_[v]) || src(vertex_to_edge_[v]) == v); return vertex_to_edge_[v]; }
  HalfedgeId prev(HalfedgeId e)             const { return halfedges_[e].prev; }
  HalfedgeId next(HalfedgeId e)             const { return halfedges_[e].next; }
  HalfedgeId reverse(HalfedgeId e)          const { assert(e.valid()); return HalfedgeId(e.id^1); }
  EdgeId     edge(HalfedgeId e)             const { assert(e.valid()); return EdgeId(e.id>>1); }
  EdgeId     edge(VertexId v)               const { return edge(halfedge(v)); } // Warning, this will fail if no edge connected to vertex exists
  HalfedgeId halfedge(EdgeId e, bool which) const { assert(e.valid()); return HalfedgeId((e.id<<1)|which); }
  VertexId   src(HalfedgeId e)              const { return halfedges_[e].src; }
  VertexId   dst(HalfedgeId e)              const { return src(reverse(e)); }
  VertexId   src(EdgeId e)                  const { return src(halfedge(e,false)); }
  VertexId   dst(EdgeId e)                  const { return src(halfedge(e,true)); }
  HalfedgeId left(HalfedgeId e)             const { return reverse(prev(e)); }
  HalfedgeId right(HalfedgeId e)            const { return next(reverse(e)); }

  // These require border data to be initialized
  BorderId   border(HalfedgeId e)           const { assert(has_all_border_data()); return halfedges_[e].border; }
  BorderId   opp_border(HalfedgeId e)       const { return border(reverse(e)); }
  HalfedgeId halfedge(BorderId b)           const { return borders_[b].halfedge; }
  BorderId   next(BorderId b)               const { return borders_[b].next; }
  BorderId   prev(BorderId b)               const { return borders_[b].prev; }

  // These require face data to be initialized
  FaceId     face(BorderId b)               const { assert(has_all_border_data()); return borders_[b].face; }
  FaceId     face(HalfedgeId e)             const { return face(border(e)); }
  FaceId     opp_face(HalfedgeId e)         const { return face(reverse(e)); }
  BorderId   border(FaceId f)               const { return faces_[f].border; }
  HalfedgeId halfedge(FaceId f)             const { return halfedge(border(f)); }

  // Check id validity
  bool valid(VertexId v)   const;
  bool valid(HalfedgeId e) const;
  bool valid(EdgeId e)     const;
  bool valid(BorderId b)   const;
  bool valid(FaceId f)     const;

  bool is_forward(HalfedgeId e) const { return (e.id&1) == 0; }
  bool isolated(VertexId v)     const { return !valid(halfedge(v)); }

  // Iterate over vertices, edges, borders, or faces
  Range<IdIter<VertexId>>   vertices()  const { return Range<IdIter<VertexId>>  (VertexId(0),  VertexId(  n_vertices())); }
  Range<IdIter<HalfedgeId>> halfedges() const { return Range<IdIter<HalfedgeId>>(HalfedgeId(0),HalfedgeId(n_halfedges())); }
  Range<IdIter<EdgeId>>     edges()     const { return Range<IdIter<EdgeId>>    (EdgeId(0),    EdgeId(    n_edges())); }
  Range<IdIter<BorderId>>   borders()   const { return Range<IdIter<BorderId>>  (BorderId(0),  BorderId(  n_borders())); }
  Range<IdIter<FaceId>>     faces()     const { return Range<IdIter<FaceId>>    (FaceId(0),    FaceId(    n_faces())); }

  Vector<VertexId,2> vertices(HalfedgeId e) const {
    return vec(src(e),dst(e));
  }
  Vector<VertexId,2> vertices(EdgeId e) const { return vertices(halfedge(e, false)); }

  inline Range<OutgoingCirculator> outgoing(VertexId v) const;
  inline Range<BorderCirculator> border_edges(HalfedgeId e) const; // This is safe to call even without border data present
  inline Range<BorderCirculator> border_edges(BorderId b) const { return border_edges(halfedge(b)); }
  inline Range<FaceCirculator> face_borders(BorderId b) const; // This relies on border data, but is safe to call without face data present
  inline Range<FaceCirculator> face_borders(FaceId f) const { return face_borders(border(f)); }

  // Find a halfedge between two vertices, or return an invalid id if none exists.
  GEODE_CORE_EXPORT HalfedgeId halfedge(VertexId v0, VertexId v1) const;

  // Compute the edge degree of a vertex in O(degree) time.
  GEODE_CORE_EXPORT int degree(VertexId v) const;

  // All connected edges to vertex
  GEODE_CORE_EXPORT Array<VertexId> one_ring(VertexId v) const;

  // Add a new isolated vertex and return its id
  GEODE_CORE_EXPORT VertexId add_vertex();

  // Add n isolated vertices
  GEODE_CORE_EXPORT void add_vertices(int n);

  GEODE_CORE_EXPORT EdgeId split_edge(const EdgeId e, const VertexId use_vertex); // Vertex must be valid, but with no edges
  GEODE_CORE_EXPORT EdgeId split_edge_across(const EdgeId e0, const HalfedgeId split);

  // Use only through HalfedgeGraph::outgoing()
  struct OutgoingCirculator {
    const HalfedgeGraph& graph;
    HalfedgeId e;
    bool first;
    OutgoingCirculator(const HalfedgeGraph& graph, HalfedgeId e, bool first) : graph(graph), e(e), first(first) {}
    void operator++() { e = graph.left(e); first = false; }
    bool operator!=(OutgoingCirculator o) { return first || e!=o.e; } // For use only inside range-based for loops
    HalfedgeId operator*() const { return e; }
  };

  // Use only through HalfedgeGraph::border_edges()
  struct BorderCirculator { // Iterator to walk halfedges for a border
    const HalfedgeGraph& graph;
    HalfedgeId e;
    bool first;
    BorderCirculator(const HalfedgeGraph& graph, HalfedgeId e, bool first) : graph(graph), e(e), first(first) {}
    void operator++() { e = graph.next(e); first = false; }
    bool operator!=(BorderCirculator o) { assert(&graph == &o.graph); return first || e!=o.e; } // For use only inside range-based for loops
    HalfedgeId operator*() const { return e; }
  };

  // Use only through HalfedgeGraph::face_borders()
  struct FaceCirculator { // Iterator to walk borders for a face
    const HalfedgeGraph& graph;
    BorderId b;
    bool first;
    FaceCirculator(const HalfedgeGraph& graph, BorderId b, bool first) : graph(graph), b(b), first(first) {}
    void operator++() { b = graph.next(b); first = false; }
    bool operator!=(FaceCirculator o) { assert(&graph == &o.graph); return first || b!=o.b; } // For use only inside range-based for loops
    BorderId operator*() const { return b; }
  };

  // The remaining functions are mainly for internal use, or for external routines that perform direct surgery
  // on the halfedge structure.  Use with caution!

  // Adds a new edge. New halfedges will be linked with arbitrarily choosen neighbor at src and dst
  EdgeId unsafe_add_edge(VertexId src, VertexId dst);

  // Link two edges together
  void unsafe_link(HalfedgeId p, HalfedgeId n) {
    halfedges_[p].next = n;
    halfedges_[n].prev = p;
    assert(dst(p) == src(n));
  }

  void unsafe_change_end(const EdgeId e, const VertexId at_vertex);

  // Face operations. These must not be called before initialize_borders
  FaceId new_face_for_border(const BorderId b); // 'b' must not already belong to a face
  void add_to_face(const FaceId f, const BorderId child); // 'f' must be a valid face. 'child' must not already belong to a face
};

std::ostream& operator<<(std::ostream& os, const HalfedgeGraph& g);

inline Range<HalfedgeGraph::OutgoingCirculator> HalfedgeGraph::outgoing(VertexId v) const {
  const auto e = halfedge(v);
  const HalfedgeGraph::OutgoingCirculator c(*this,e,e.valid());
  return Range<HalfedgeGraph::OutgoingCirculator>(c,c);
}

inline Range<HalfedgeGraph::BorderCirculator> HalfedgeGraph::border_edges(HalfedgeId e) const {
  const BorderCirculator iter(*this,e,e.valid());
  return Range<BorderCirculator>(iter,iter);
}

inline Range<HalfedgeGraph::FaceCirculator> HalfedgeGraph::face_borders(BorderId b) const {
  assert(has_all_border_data());
  const FaceCirculator iter(*this,b,b.valid());
  return Range<FaceCirculator>(iter,iter);
}

struct CrossingInfo {
  static int unset_depth() { return std::numeric_limits<int>::max(); }
  HalfedgeId next;
  int depth;
  CrossingInfo()
   : next(HalfedgeId())
   , depth(unset_depth())
  { }
};
// Compute shortest path (in edge crossings) from each face to boundary_face.  This is always nonnegative.
// Requires face(he).valid() == face(reverse(he)).valid()
Field<CrossingInfo, FaceId> get_crossing_depths(const HalfedgeGraph& g, const FaceId boundary_face);

// Compute winding numbers for all faces starting with a value of 0 inside boundary_face and using edge_weights
// If e is an EdgeId, the weight for 'g.halfedge(e,0)' will be 'edge_weights[e]' and the weight for 'g.halfedge(e,1)' will be '-edge_weights[e]'
// Requires face(he).valid() == face(reverse(he)).valid()
Field<int, FaceId> compute_winding_numbers(const HalfedgeGraph& g, const FaceId boundary_face, const RawField<const int, EdgeId> edge_weights);

// Compute interior and exterior boundaries of region for union of all faces that are true in interior_faces
// Requires face(he).valid() == face(reverse(he)).valid() and will ignore components with invalid faces
Nested<HalfedgeId> extract_region(const HalfedgeGraph& g, const RawField<const bool, FaceId> interior_faces);

} // namespace geode