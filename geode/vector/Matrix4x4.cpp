//#####################################################################
// Class Matrix<T,4>
//#####################################################################
#include <geode/vector/Matrix4x4.h>
namespace geode {

template<class T> Matrix<T,4> Matrix<T,4>::
operator*(const Matrix& A) const
{
    return Matrix(x[0][0]*A.x[0][0]+x[0][1]*A.x[1][0]+x[0][2]*A.x[2][0]+x[0][3]*A.x[3][0],x[1][0]*A.x[0][0]+x[1][1]*A.x[1][0]+x[1][2]*A.x[2][0]+x[1][3]*A.x[3][0],
                  x[2][0]*A.x[0][0]+x[2][1]*A.x[1][0]+x[2][2]*A.x[2][0]+x[2][3]*A.x[3][0],x[3][0]*A.x[0][0]+x[3][1]*A.x[1][0]+x[3][2]*A.x[2][0]+x[3][3]*A.x[3][0],
                  x[0][0]*A.x[0][1]+x[0][1]*A.x[1][1]+x[0][2]*A.x[2][1]+x[0][3]*A.x[3][1],x[1][0]*A.x[0][1]+x[1][1]*A.x[1][1]+x[1][2]*A.x[2][1]+x[1][3]*A.x[3][1],
                  x[2][0]*A.x[0][1]+x[2][1]*A.x[1][1]+x[2][2]*A.x[2][1]+x[2][3]*A.x[3][1],x[3][0]*A.x[0][1]+x[3][1]*A.x[1][1]+x[3][2]*A.x[2][1]+x[3][3]*A.x[3][1],
                  x[0][0]*A.x[0][2]+x[0][1]*A.x[1][2]+x[0][2]*A.x[2][2]+x[0][3]*A.x[3][2],x[1][0]*A.x[0][2]+x[1][1]*A.x[1][2]+x[1][2]*A.x[2][2]+x[1][3]*A.x[3][2],
                  x[2][0]*A.x[0][2]+x[2][1]*A.x[1][2]+x[2][2]*A.x[2][2]+x[2][3]*A.x[3][2],x[3][0]*A.x[0][2]+x[3][1]*A.x[1][2]+x[3][2]*A.x[2][2]+x[3][3]*A.x[3][2],
                  x[0][0]*A.x[0][3]+x[0][1]*A.x[1][3]+x[0][2]*A.x[2][3]+x[0][3]*A.x[3][3],x[1][0]*A.x[0][3]+x[1][1]*A.x[1][3]+x[1][2]*A.x[2][3]+x[1][3]*A.x[3][3],
                  x[2][0]*A.x[0][3]+x[2][1]*A.x[1][3]+x[2][2]*A.x[2][3]+x[2][3]*A.x[3][3],x[3][0]*A.x[0][3]+x[3][1]*A.x[1][3]+x[3][2]*A.x[2][3]+x[3][3]*A.x[3][3]);
}

template<class T> void Matrix<T,4>::
invert()
{
    *this=inverse();
}

template<class T> Matrix<T,4> Matrix<T,4>::
inverse() const
{
    int pivot_row;T p0=abs(x[0][0]),p1=abs(x[1][0]),p2=abs(x[2][0]),p3=abs(x[3][0]);
    if(p0>p1){if(p0>p2){if(p0>p3) pivot_row=0;else pivot_row=3;}else if(p2>p3) pivot_row=2;else pivot_row=3;}
    else if(p1>p2){if(p1>p3) pivot_row=1;else pivot_row=3;}
    else if(p2>p3) pivot_row=2;else pivot_row=3;
    T a=x[pivot_row][0];assert(a!=0);
    Vector<T,3> b(x[pivot_row][1],x[pivot_row][2],x[pivot_row][3]),c;Matrix<T,3> d;
    switch(pivot_row){
        case 0:c=Vector<T,3>(x[1][0],x[2][0],x[3][0]);d=Matrix<T,3>(x[1][1],x[2][1],x[3][1],x[1][2],x[2][2],x[3][2],x[1][3],x[2][3],x[3][3]);break;
        case 1:c=Vector<T,3>(x[0][0],x[2][0],x[3][0]);d=Matrix<T,3>(x[0][1],x[2][1],x[3][1],x[0][2],x[2][2],x[3][2],x[0][3],x[2][3],x[3][3]);break;
        case 2:c=Vector<T,3>(x[0][0],x[1][0],x[3][0]);d=Matrix<T,3>(x[0][1],x[1][1],x[3][1],x[0][2],x[1][2],x[3][2],x[0][3],x[1][3],x[3][3]);break;
        default:c=Vector<T,3>(x[0][0],x[1][0],x[2][0]);d=Matrix<T,3>(x[0][1],x[1][1],x[2][1],x[0][2],x[1][2],x[2][2],x[0][3],x[1][3],x[2][3]);}
    T m=-1/a;b*=m;d+=outer_product(c,b); // find schur complement
    Matrix<T,3> h=d.inverse();Vector<T,3> g=h*(c*m);Vector<T,3> f=b*h;T e=dot(b,g)-m; // compute parts of inverse
    switch(pivot_row){
        case 0:return Matrix(e,g.x,g.y,g.z,f.x,h(0,0),h(1,0),h(2,0),f.y,h(0,1),h(1,1),h(2,1),f.z,h(0,2),h(1,2),h(2,2));break;
        case 1:return Matrix(f.x,h(0,0),h(1,0),h(2,0),e,g.x,g.y,g.z,f.y,h(0,1),h(1,1),h(2,1),f.z,h(0,2),h(1,2),h(2,2));break;
        case 2:return Matrix(f.x,h(0,0),h(1,0),h(2,0),f.y,h(0,1),h(1,1),h(2,1),e,g.x,g.y,g.z,f.z,h(0,2),h(1,2),h(2,2));break;}
    return Matrix(f.x,h(0,0),h(1,0),h(2,0),f.y,h(0,1),h(1,1),h(2,1),f.z,h(0,2),h(1,2),h(2,2),e,g.x,g.y,g.z);
}

template<class T> Matrix<T,4> Matrix<T,4>::
cofactor_matrix() const
{
    T y[16];
    y[0]=x[1][1]*x[2][2]*x[3][3]+x[1][2]*x[2][3]*x[3][1]+x[1][3]*x[2][1]*x[3][2]-x[1][1]*x[2][3]*x[3][2]-x[1][2]*x[2][1]*x[3][3]-x[1][3]*x[2][2]*x[3][1];
    y[1]=-x[2][1]*x[3][2]*x[0][3]-x[2][2]*x[3][3]*x[0][1]-x[2][3]*x[3][1]*x[0][2]+x[2][1]*x[3][3]*x[0][2]+x[2][2]*x[3][1]*x[0][3]+x[2][3]*x[3][2]*x[0][1];
    y[2]=x[3][1]*x[0][2]*x[1][3]+x[3][2]*x[0][3]*x[1][1]+x[3][3]*x[0][1]*x[1][2]-x[3][1]*x[0][3]*x[1][2]-x[3][2]*x[0][1]*x[1][3]-x[3][3]*x[0][2]*x[1][1];
    y[3]=-x[0][1]*x[1][2]*x[2][3]-x[0][2]*x[1][3]*x[2][1]-x[0][3]*x[1][1]*x[2][2]+x[0][1]*x[1][3]*x[2][2]+x[0][2]*x[1][1]*x[2][3]+x[0][3]*x[1][2]*x[2][1];
    y[4]=-x[1][2]*x[2][3]*x[3][0]-x[1][3]*x[2][0]*x[3][2]-x[1][0]*x[2][2]*x[3][3]+x[1][2]*x[2][0]*x[3][3]+x[1][3]*x[2][2]*x[3][0]+x[1][0]*x[2][3]*x[3][2];
    y[5]=x[2][2]*x[3][3]*x[0][0]+x[2][3]*x[3][0]*x[0][2]+x[2][0]*x[3][2]*x[0][3]-x[2][2]*x[3][0]*x[0][3]-x[2][3]*x[3][2]*x[0][0]-x[2][0]*x[3][3]*x[0][2];
    y[6]=-x[3][2]*x[0][3]*x[1][0]-x[3][3]*x[0][0]*x[1][2]-x[3][0]*x[0][2]*x[1][3]+x[3][2]*x[0][0]*x[1][3]+x[3][3]*x[0][2]*x[1][0]+x[3][0]*x[0][3]*x[1][2];
    y[7]=x[0][2]*x[1][3]*x[2][0]+x[0][3]*x[1][0]*x[2][2]+x[0][0]*x[1][2]*x[2][3]-x[0][2]*x[1][0]*x[2][3]-x[0][3]*x[1][2]*x[2][0]-x[0][0]*x[1][3]*x[2][2];
    y[8]=x[1][3]*x[2][0]*x[3][1]+x[1][0]*x[2][1]*x[3][3]+x[1][1]*x[2][3]*x[3][0]-x[1][3]*x[2][1]*x[3][0]-x[1][0]*x[2][3]*x[3][1]-x[1][1]*x[2][0]*x[3][3];
    y[9]=-x[2][3]*x[3][0]*x[0][1]-x[2][0]*x[3][1]*x[0][3]-x[2][1]*x[3][3]*x[0][0]+x[2][3]*x[3][1]*x[0][0]+x[2][0]*x[3][3]*x[0][1]+x[2][1]*x[3][0]*x[0][3];
    y[10]=x[3][3]*x[0][0]*x[1][1]+x[3][0]*x[0][1]*x[1][3]+x[3][1]*x[0][3]*x[1][0]-x[3][3]*x[0][1]*x[1][0]-x[3][0]*x[0][3]*x[1][1]-x[3][1]*x[0][0]*x[1][3];
    y[11]=-x[0][3]*x[1][0]*x[2][1]-x[0][0]*x[1][1]*x[2][3]-x[0][1]*x[1][3]*x[2][0]+x[0][3]*x[1][1]*x[2][0]+x[0][0]*x[1][3]*x[2][1]+x[0][1]*x[1][0]*x[2][3];
    y[12]=-x[1][0]*x[2][1]*x[3][2]-x[1][1]*x[2][2]*x[3][0]-x[1][2]*x[2][0]*x[3][1]+x[1][0]*x[2][2]*x[3][1]+x[1][1]*x[2][0]*x[3][2]+x[1][2]*x[2][1]*x[3][0];
    y[13]=x[2][0]*x[3][1]*x[0][2]+x[2][1]*x[3][2]*x[0][0]+x[2][2]*x[3][0]*x[0][1]-x[2][0]*x[3][2]*x[0][1]-x[2][1]*x[3][0]*x[0][2]-x[2][2]*x[3][1]*x[0][0];
    y[14]=-x[3][0]*x[0][1]*x[1][2]-x[3][1]*x[0][2]*x[1][0]-x[3][2]*x[0][0]*x[1][1]+x[3][0]*x[0][2]*x[1][1]+x[3][1]*x[0][0]*x[1][2]+x[3][2]*x[0][1]*x[1][0];
    y[15]=x[0][0]*x[1][1]*x[2][2]+x[0][1]*x[1][2]*x[2][0]+x[0][2]*x[1][0]*x[2][1]-x[0][0]*x[1][2]*x[2][1]-x[0][1]*x[1][0]*x[2][2]-x[0][2]*x[1][1]*x[2][0];
    return Matrix(y[0],y[1],y[2],y[3],y[4],y[5],y[6],y[7],y[8],y[9],y[10],y[11],y[12],y[13],y[14],y[15]);
}

typedef real T;
template Matrix<T,4> Matrix<T,4>::operator*(const Matrix&) const;
template void Matrix<T,4>::invert();
template Matrix<T,4> Matrix<T,4>::inverse() const;
template Matrix<T,4> Matrix<T,4>::cofactor_matrix() const;
}
