#!/usr/bin/env python
'''Small integer arithmetic code generator

GMP is a wonderful library for large integers, but is a bit overkill
for integers which are only a few limbs (say up to 8*64 bits).  Therefore,
in the gcc/clang case we generate our own fixed size arithmetic routines.'''

from __future__ import division,print_function,unicode_literals,absolute_import
from contextlib import *
import sys
import os
import re

# Utilities

def sub(_s,**subs):
  if not subs: return _s
  return re.sub(r'(?:\{)?\b('+'|'.join(subs.keys())+r')\b(?:\})?',lambda m:str(subs[m.group(1)]),_s)

indentation = 0
@contextmanager
def indent(steps=1,close=True,open=False):
  global indentation
  if open and steps:
    write('{') 
  indentation += steps
  try:
    yield
  finally:
    indentation -= steps
    if close and steps:
      write('}')

def write(_s='',**env):
  for line in sub(_s,**env).split('\n'):
    print('  '*(indentation*bool(line))+line)

# Redirect stdout to exact-generated.h
os.chdir(os.path.dirname(__file__))
sys.stdout = open('exact-generated.h','w')

print('''\
// Autogenerated by exact/gen-exact.  Do not edit directly!

static_assert(sizeof(mp_limb_t)==8 && sizeof(Quantized)==8,
              "The generated routines below are for 64-bit use only");''')

# Add and subtract
write('''
#define ADDER(op,i) { \\
  const auto t = __uint128_t(x.n[i]) op y.n[i] op carry; \\
  carry = t>>64; \\
  r.n[i] = uint64_t(t); }''')
for a in range(1,9+1)+[12,15]:
  for op in '+','-':
    write('GEODE_PURE static inline Exact<a> operator{op}(const Exact<a> x, const Exact<a> y) {',a=a,op=op)
    with indent():
      write('Exact<a> r(uninit);',a=a)
      write('bool carry = 0;')
      write(' '.join('ADDER(%s,%d)'%(op,i) for i in xrange(a)))
      write('return r;')

'''
We multiply 2's complement numbers using the Baugh-Wooley algorithm.
Let e(x) be the sign extended version of x.  That is,

  e(0) = 0
  e(1) = -1
  x    = sum_{i<n} x_i 2^i
  e(x) = e(x_{n-1}) 2^{n-1} + sum_{i<n-1} x_i 2^i

If we operate in base b, we recursively have

  y = sum_{i<n} y_i b^i
  e(y) = e(y_{n-1}) + sum_{i<n-1} y_i b^i

where e(y_{n-1}) operates on the entire uppermost limb.  If x,y are limbs, we have the rules

  e(x)y = e(xy)     - negative
  e(x)e(y) = s(xy)  - positive, but computed with signed multiplication
  lo(e(x)b+y) = y
  hi(e(x)b+y) = e(x)

What if we add a bunch of 64-bit numbers?  If they're all nonextended nothing need be
done.  If any are extended we further extend out to 128 bits and extend the result.
'''

# Multiply and square
for a,b in ((1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),
            (5,4),(6,1),(6,2),(6,3),(6,6),(7,1),(7,2),(7,5),(7,6),(8,7),(9,3)):
  assert a >= b
  for f in ('operator*',)+('sqr',)*(a==b):
    write('GEODE_PURE static inline Exact<ab> f(const Exact<a> x{y}) {',
      f=f,a=a,ab=a+b,y=', const Exact<%d> y'%b*('*' in f))
    y = 'x' if f=='sqr' else 'y'
    with indent():
      write('Exact<ab> r(uninit);',ab=a+b)
      write('typedef __uint128_t B;')
      _new = [0]
      def new():
        t = 't%d'%_new[0]
        _new[0] += 1
        return t
      terms = [[] for i in xrange(a+b)]
      for i in xrange(a):
        for j in xrange(b):
          t,lo,hi = new(),new(),new()
          e = (i==a-1)^(j==b-1)
          write('const auto t = B(%s)*B(%s);'%(
            'int64_t(x.n[i])' if i==a-1 else 'x.n[i]',
            'int64_t(y.n[j])' if j==b-1 else 'y.n[j]'),
            i=i,j=j,y=y,t=t)
          write('const auto lo = uint64_t(t);',t=t,lo=lo)
          write('const auto hi = {u}int64_t(t>>64);',t=t,hi=hi,u='u'*(not e))
          terms[i+j].append(lo)
          terms[i+j+1].append(hi)
      for k in xrange(a+b):
        def sum(ts):
          if len(ts)==1:
            return ts[0],False
          s = new()
          write('const auto s = all;',s=s,all='+'.join('B(%s)'%t for t in ts))
          return s,True
        s,carried = sum(terms[k])
        write('r.n[k] = uint64_t(s);',k=k,s=s)
        if carried and k+1 < a+b:
          t = new()
          write('const auto t = int64_t(s>>64);',t=t,s=s)
          terms[k+1].append(t)
      write('return r;')

# Shift
for a in xrange(1,4+1):
  write('GEODE_PURE static inline Exact<a> operator<<(const Exact<a> x, const int s) {',a=a)
  with indent():
    write('assert(unsigned(s)<3);')
    write('Exact<a> r(uninit);',a=a)
    for i in xrange(a):
      write('const auto t{i} = __uint128_t(x.n[i])<<s;',i=i)
    for i in xrange(a):
      write('r.n[i] = uint64_t(t{i})extra;',i=i,extra=' | uint64_t(t%d>>64)'%(i-1) if i else '')
    write('return r;')
